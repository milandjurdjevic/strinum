using System.CodeDom.Compiler;
using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Strinum;

[Generator]
public class Generator : IIncrementalGenerator
{
    private const string StringifyAttributeNamespace = nameof(Strinum);
    private const string StringifyAttributeClassName = "StringifyAttribute";
    private const string StringifyAttributeMetaName = $"{StringifyAttributeNamespace}.{StringifyAttributeClassName}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(GenerateOutput);

        IncrementalValueProvider<ImmutableArray<ISymbol?>> provider = context.SyntaxProvider
            .CreateSyntaxProvider(Filter, Transform)
            .Collect();

        context.RegisterSourceOutput(provider, GenerateOutput);
    }

    private static void GenerateOutput(IncrementalGeneratorPostInitializationContext context)
    {
        // lang=csharp
        const string source = $$"""
                                // <auto-generated />
                                namespace {{StringifyAttributeNamespace}}
                                {
                                    [global::System.AttributeUsage(AttributeTargets.Field)]
                                    public sealed class {{StringifyAttributeClassName}} : global::System.Attribute
                                    {
                                        public {{StringifyAttributeClassName}}(string value)
                                        {
                                            Value = value;
                                        }
                                        
                                        public string Value { get; }
                                    }
                                }
                                """;

        context.AddSource($"{StringifyAttributeMetaName}.g.cs", source);
    }

    private static void GenerateOutput(SourceProductionContext context, ImmutableArray<ISymbol?> symbols)
    {
        IndentedTextWriter writer = new(new StringWriter());
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine("namespace Strinum");
        writer.WriteLine('{');
        writer.Indent++;
        writer.WriteLine("public static class Extensions");
        writer.WriteLine('{');
        writer.Indent++;
        foreach (ITypeSymbol symbol in symbols.OfType<ITypeSymbol>())
        {
            writer.WriteLine($"public static string Stringify(this global::{symbol.ToDisplayString()} enumeration)");
            writer.WriteLine('{');
            writer.Indent++;
            writer.WriteLine("return enumeration switch");
            writer.WriteLine('{');
            writer.Indent++;

            foreach (IFieldSymbol field in symbol.GetMembers().OfType<IFieldSymbol>())
            {
                AttributeData? attribute = field.GetAttributes().SingleOrDefault(a =>
                    a.AttributeClass?.ToDisplayString() == StringifyAttributeMetaName);

                if (attribute is { ConstructorArguments.IsEmpty: false })
                {
                    string? value = attribute.ConstructorArguments[0].Value?.ToString();
                    writer.WriteLine($"global::{field.ToDisplayString()} => \"{value}\",");
                }
                else
                {
                    writer.WriteLine($"global::{field.ToDisplayString()} => \"{field.Name}\",");
                }
            }

            writer.WriteLine("_ => global::System.String.Empty");
            writer.Indent--;
            writer.WriteLine("};");
            writer.Indent--;
            writer.WriteLine('}');
        }

        writer.Indent--;
        writer.WriteLine('}');
        writer.Indent--;
        writer.WriteLine('}');
        context.AddSource("Strinum.Extensions.g.cs", writer.InnerWriter.ToString());
    }

    private static ISymbol? Transform(GeneratorSyntaxContext context, CancellationToken token)
    {
        return context.SemanticModel.GetDeclaredSymbol(context.Node);
    }

    private static bool Filter(SyntaxNode node, CancellationToken token)
    {
        return node is EnumDeclarationSyntax;
    }
}