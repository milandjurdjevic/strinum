using System.CodeDom.Compiler;
using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Strinum;

[Generator]
public class Generator : IIncrementalGenerator
{
    private const string MarkerMetadataName = "System.ComponentModel.DescriptionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<ImmutableArray<Member>> provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(MarkerMetadataName, Filter, Transform)
            .Collect();

        context.RegisterSourceOutput(provider, (productionContext, members) =>
        {
            IndentedTextWriter writer = new(new StringWriter());

            writer.WriteLine("// <auto-generated />");
            writer.WriteLine("namespace Strinum");
            writer.WriteLine('{');
            writer.Indent++;
            writer.WriteLine("public static class EnumExtensions");
            writer.WriteLine('{');
            writer.Indent++;

            IEnumerable<IGrouping<ITypeSymbol, Member>> groups = members
                .GroupBy(member => member.Type, EqualityComparer<ITypeSymbol>.Default);
            foreach (IGrouping<ITypeSymbol, Member> group in groups)
            {
                string groupMetadataName = group.Key.ToDisplayString();
                writer.WriteLine($"public static string GetDescription(this global::{groupMetadataName} enumeration)");
                writer.WriteLine('{');
                writer.Indent++;
                writer.WriteLine("return enumeration switch");
                writer.WriteLine('{');
                writer.Indent++;

                foreach (Member member in group)
                {
                    writer.WriteLine($"{member.Key} => {member.Value},");
                }

                writer.WriteLine("_ => global::System.String.Empty");

                writer.Indent--;
                writer.WriteLine("};");
                writer.Indent--;
                writer.WriteLine('}');
            }

            writer.Indent--;
            writer.WriteLine('}');
            writer.Indent--;
            writer.WriteLine('}');

            productionContext.AddSource("Strinum.EnumExtensions.g.cs", writer.InnerWriter.ToString());
        });
    }

    private static Member Transform(GeneratorAttributeSyntaxContext context, CancellationToken token)
    {
        AttributeData marker = context.Attributes
            .Single(attribute => attribute.AttributeClass?.ToDisplayString() == MarkerMetadataName);

        return new Member(context.TargetSymbol, marker);
    }

    private static bool Filter(SyntaxNode node, CancellationToken token)
    {
        return node is EnumMemberDeclarationSyntax { Parent: EnumDeclarationSyntax enumDeclaration } &&
               (enumDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword) ||
                enumDeclaration.Modifiers.Any(SyntaxKind.InternalKeyword));
    }
}