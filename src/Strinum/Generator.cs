using System.CodeDom.Compiler;
using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Strinum;

[Generator]
public class Generator : IIncrementalGenerator
{
    private const string Namespace = nameof(Strinum);
    private const string AttributeClassName = "StringEnumAttribute";
    private const string AttributeClassMeta = $"{Namespace}.{AttributeClassName}";
    private const string ConverterClassName = "StringEnum";
    private const string ConverterClassMeta = "Strinum.StringEnum";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(GenerateOutput);

        IncrementalValueProvider<ImmutableArray<ISymbol?>> provider = context.SyntaxProvider
            .CreateSyntaxProvider(Filter, Transform)
            .Collect();

        context.RegisterSourceOutput(provider, GenerateOutput);
    }

    private static void GenerateOutput(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource($"{AttributeClassMeta}.g.cs",
            // lang=csharp
            $$"""
              // <auto-generated />
              namespace {{Namespace}}
              {
                  [global::System.AttributeUsage(AttributeTargets.Field)]
                  public sealed class {{AttributeClassName}} : global::System.Attribute
                  {
                      public {{AttributeClassName}}(string value)
                      {
                          Value = value;
                      }
                      
                      public string Value { get; }
                  }
              }
              """);

        context.AddSource($"{ConverterClassMeta}.Partial.g.cs",
            // lang=csharp
            $$"""
              // <auto-generated />
              namespace {{Namespace}}
              {
                  public static partial class {{ConverterClassName}}
                  {
                      public static partial string ToString<T>(T value) where T : global::System.Enum;
                  }
              }
              """);
    }

    private static void GenerateOutput(SourceProductionContext context, ImmutableArray<ISymbol?> symbols)
    {
        IndentedTextWriter writer = new(new StringWriter());
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine($"namespace {Namespace}");
        writer.WriteLine('{');
        writer.Indent++;
        writer.WriteLine($"public static partial class {ConverterClassName}");
        writer.WriteLine('{');
        writer.Indent++;

        writer.WriteLine("public static partial string ToString<T>(T value) where T : global::System.Enum");
        writer.WriteLine('{');
        writer.Indent++;
        writer.WriteLine("return value switch");
        writer.WriteLine('{');
        writer.Indent++;

        foreach (ITypeSymbol symbol in symbols.Distinct(SymbolEqualityComparer.Default).OfType<ITypeSymbol>())
        {
            writer.WriteLine($"global::{symbol.ToDisplayString()} casted => casted switch");
            writer.WriteLine('{');
            writer.Indent++;

            foreach (IFieldSymbol field in symbol.GetMembers().OfType<IFieldSymbol>())
            {
                AttributeData? attribute = field.GetAttributes().SingleOrDefault(a =>
                    a.AttributeClass?.ToDisplayString() == AttributeClassMeta);

                string? value = attribute is { ConstructorArguments.IsEmpty: false }
                    ? attribute.ConstructorArguments[0].Value?.ToString()
                    : field.Name;

                writer.WriteLine($"global::{field.ToDisplayString()} => \"{value}\",");
            }

            writer.WriteLine("_ => global::System.String.Empty");
            writer.Indent--;
            writer.WriteLine("},");
        }


        writer.WriteLine("_ => global::System.String.Empty");
        writer.Indent--;
        writer.WriteLine("};");

        writer.Indent--;
        writer.WriteLine('}');

        writer.Indent--;
        writer.WriteLine('}');

        writer.Indent--;
        writer.WriteLine('}');

        context.AddSource($"{ConverterClassMeta}.g.cs", writer.InnerWriter.ToString());
    }

    private static ISymbol? Transform(GeneratorSyntaxContext context, CancellationToken token)
    {
        SymbolInfo info = context.SemanticModel.GetSymbolInfo(context.Node);
        return info.Symbol is IMethodSymbol method && method.ContainingType.ToDisplayString() == ConverterClassMeta
            ? method.TypeArguments.SingleOrDefault()
            : null;
    }

    private static bool Filter(SyntaxNode node, CancellationToken token)
    {
        return node is MemberAccessExpressionSyntax member && member.ToFullString() == $"{ConverterClassName}.ToString";
    }
}